# 组件通信方式

## 方式一: provide 和 inject

> 用于多层传值, provide 在父组件中使用,inject 在后代中使用
> 无论组件层次结构有多深，父组件都可以作为其所有子组件的依赖提供者。

```vue
<template>
  <!-- 我是父组件 -->
  <Child></Child>
</template>

<script setup>
import { provide, ref, readonly } from "vue";
import Child from "./components/Child.vue";

// 数据
const name = ref("小明同学");
const msg = ref("真好喝!");

// provide 方法"
//使用readonly可以让子组件无法直接修改，需要调用provide往下传的方法来修改
provide("name", readonly(name));
provide("msg", msg);

provide("changeName", (value) => {
  name.value = value;
});
</script>
```

```vue
<template>
  <div>
    <!-- 我是孩子组件 -->
    <div>msg: {{ msg }}</div>
    <div>name: {{ name }}</div>
    <button @click="handleClick">修改</button>
  </div>
</template>

<script setup>
import { inject } from "vue";

// 从inject中取值
const msg = inject("msg", "默认值");
const name = inject("name", "默认值");
const changeName = inject("changeName");

//自身的方法:
const handleClick = () => {
  changeName("小爱同学");
  msg.value = "来了!";
};
</script>
```

## 方式二: Props

> 只能实现父传子 优点是简单,用的概况大.

```vue
<template>
  <!-- 我是父组件 -->
  <Son :list="DataList"></Son>
</template>

<script setup>
import Son from "./components/Son.vue";
import { ref } from "vue";

let DataList = ref([]);
</script>
```

```vue
<template>
  <!-- 我是子组件 -->
  <div v-for="item in DataList"></div>
</template>

<script setup>
const props = defineProps({
  DataList: {
    type: Array,
    default: [],
    required: true,
  },
});
// 在js中使用,是使用 props.DataList
// 在template中使用,直接使用即可
</script>
```

## 方式三: emits

> 子组件通知父组件触发一个事件，并且可以传值给父组件

```vue
<template>
  <!-- 我是父组件 -->
  <div>{{ msg }}</div>

  <!-- 自定义事件changeMsg -->
  <Child @changeMsg="changeMessage"></Child>
</template>

<script setup>
import Child from "./components/Child.vue";
import { ref } from "vue";

let message = ref("小爱同学");

// 此时的data是由子组件传递过来的值
const changeMessage = (data) => {
  message.value = data;
};
</script>
```

```vue
<template>
  <div>子组件：<button @click="handleClick">子组件的按钮</button></div>
</template>

<script setup>
// 可以是有多个自定义的事件 此处填上自定义事件名
const emit = defineEmits(["changeMsg", "多个自定义的事件"]);

// 选择调用的时机
const handleClick = () => {
  // 参数1：事件名
  // 参数2：传给父组件的值
  emit("changeMsg", "参数2：传给父组件的值");
};
</script>
```

## 方式四: ref 和 expose

> 子组件通过 expose 来暴露自身的方法和数据
> 父组件通过给子组件打上 ref,来获取子组件并调用其方法或访问数据。

```vue
<template>
  <div>父组件拿到子组件数据: {{ msg }}</div>
  <button @click="callChildFn">父组件调用子组件方法:</button>

  <Child ref="Son"></Child>
</template>

<script setup>
import { ref, onMounted } from "vue";
import Child from "./components/Child.vue";

// 通过 模板ref 绑定子组件 名字就是绑定那个ref绑定的值
const Son = ref(null);
const msg = ref("");
// 加载完成后.将子组件的值赋给父组件  需要保证子组件有那个方法和属性
onMounted(()=>{
    msg.value = Son.value.message
})

const callChildFn () =>{
    //子组件的方法,直接调用
    Son.value.changeMessage('小爱同学')
    // 此时子组件的值已经被改变了,重新赋给父组件
    msg.value = Son.value.message
}
</script>
```

```vue
<template>
  <div>子组件：{{ message }}</div>
</template>

<script setup>
import { ref } from "vue";

const message = ref("小明同学");
const changeMessage = (data) => {
  message.value = data;
};

// 此处父组件仍然不能够,拿到子组件的方法和属性.需要对外暴露
defineExpose({
  message,
  changeMessage,
});
</script>
```
